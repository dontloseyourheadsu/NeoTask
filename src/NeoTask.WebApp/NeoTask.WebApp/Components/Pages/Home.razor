@page "/"
@rendermode InteractiveServer
@using NeoTask.Domain.Tasks.Attributes
@using NeoTask.Domain.Tasks
@using NeoTask.WebApp.Services
@using NeoTask.WebApp.Services.Tasks.Queries
@inject IScrollInfoService scrollInfoService
@inject ITaskQueryService TaskService
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>Home</PageTitle>

@if (FocusedTask == null)
{
    <div class="task-list-scroll-container">
        @foreach (var task in AllTasks)
        {
            <div id="@($"task-{task.Id}")" class="task-card" @onclick="() => SelectTask(task)">
                <span class="dimmed-title">@task.Title</span>
            </div>
        }
    </div>
}
else
{
    <div class="focus-container">
        <button class="unfocus-btn" @onclick="Unfocus">Unfocus Task</button>

        <div class="task-list-container" id="taskList">
            @foreach (var task in VisibleTasks)
            {
                @if (task != null)
                {
                    <div id="@($"task-{task.Id}")" class="task-card @GetTaskClass(task)" @onclick="() => SelectTask(task)">

                        @if (task.Id == FocusedTask?.Id)
                        {
                            <div class="focused-content">
                                <h1 class="task-title">@task.Title</h1>
                                <button class="break-down-btn" @onclick:stopPropagation="true">Break Down</button>
                                <p class="task-desc">@task.Description</p>
                            </div>
                        }
                        else
                        {
                            <span class="dimmed-title">@task.Title</span>
                        }
                    </div>
                }
                else
                {
                    <div class="task-card empty-slot"></div>
                }
            }
        </div>

        <div class="controls">
            <button class="control-btn" @onclick="MoveUp">
                <span class="material-icons">arrow_upward</span>
                <span>Up</span>
            </button>
            <button class="control-btn" @onclick="MoveDown">
                <span class="material-icons">arrow_downward</span>
                <span>Down</span>
            </button>
        </div>
    </div>
}

@code {
    private List<NeoTaskCore> AllTasks = new();
    private LinkedList<NeoTaskCore?> VisibleTasks = new();
    private NeoTaskCore? FocusedTask;
    private int _firstVisibleIndex = 0;
    private const int DefaultWindowSize = 20;
    private const int FocusedWindowSize = 3;

    protected override void OnInitialized()
    {
        AllTasks = TaskService.GetTasks().ToList();
        // No need to initialize list view for scrolling mode as we render AllTasks directly
        FocusedTask = null;

        scrollInfoService.OnScroll += OnScroll;
    }

    private void OnScroll(object? sender, int yValue)
    {
        // Only handle custom scroll when focused
        if (FocusedTask == null) return;

        // yValue from wheel event is deltaY (positive = down, negative = up)
        // Or scroll position if actual scroll.
        // Since we use wheel for navigation in fixed container:
        if (yValue > 0)
        {
            InvokeAsync(MoveDown);
        }
        else if (yValue < 0)
        {
            InvokeAsync(MoveUp);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await scrollInfoService.InitializeAsync();
        }
    }

    public void Dispose()
    {
        scrollInfoService.OnScroll -= OnScroll;
    }

    private string GetTaskClass(NeoTaskCore task)
    {
        if (FocusedTask?.Id == task.Id) return "focused";
        if (FocusedTask != null) return "dimmed";
        return "";
    }

    private void SelectTask(NeoTaskCore task)
    {
        FocusedTask = task;
        UpdateFocusedView();
        StateHasChanged();
    }

    private void UpdateFocusedView()
    {
        if (FocusedTask == null) return;

        VisibleTasks.Clear();
        int index = AllTasks.FindIndex(t => t.Id == FocusedTask.Id);

        // Previous
        if (index > 0) VisibleTasks.AddLast(AllTasks[index - 1]);
        else VisibleTasks.AddLast((NeoTaskCore?)null);

        // Current
        VisibleTasks.AddLast(FocusedTask);

        // Next
        if (index < AllTasks.Count - 1) VisibleTasks.AddLast(AllTasks[index + 1]);
        else VisibleTasks.AddLast((NeoTaskCore?)null);
    }

    private void Unfocus()
    {
        FocusedTask = null;
        StateHasChanged();
    }

    private void MoveUp()
    {
        if (FocusedTask == null) return;
        MoveFocusUp();
        StateHasChanged();
    }

    private void MoveDown()
    {
        if (FocusedTask == null) return;
        MoveFocusDown();
        StateHasChanged();
    }

    private void MoveFocusUp()
    {
        if (FocusedTask == null) return;

        int index = AllTasks.FindIndex(t => t.Id == FocusedTask.Id);
        if (index > 0)
        {
            FocusedTask = AllTasks[index - 1];

            // Update VisibleTasks for sliding window
            VisibleTasks.RemoveLast();

            int newPrevIndex = index - 2;
            if (newPrevIndex >= 0)
                VisibleTasks.AddFirst(AllTasks[newPrevIndex]);
            else
                VisibleTasks.AddFirst((NeoTaskCore?)null);
        }
    }

    private void MoveFocusDown()
    {
        if (FocusedTask == null) return;

        int index = AllTasks.FindIndex(t => t.Id == FocusedTask.Id);
        if (index < AllTasks.Count - 1)
        {
            FocusedTask = AllTasks[index + 1];

            // Update VisibleTasks for sliding window
            VisibleTasks.RemoveFirst();

            int newNextIndex = index + 2;
            if (newNextIndex < AllTasks.Count)
                VisibleTasks.AddLast(AllTasks[newNextIndex]);
            else
                VisibleTasks.AddLast((NeoTaskCore?)null);
        }
    }

    private async Task ScrollToTask(Guid taskId)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", $"document.getElementById('task-{taskId}').scrollIntoView({{ behavior: 'smooth', block: 'center' }})");
        }
        catch
        {
            // Ignore JS errors for now
        }
    }
}